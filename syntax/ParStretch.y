-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParStretch where
import AbsStretch
import LexStretch
import ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pProgram Program
%name pBoolean Boolean
%name pLiteral Literal
%name pType Type
%name pListType ListType
%name pStm Stm
%name pListStm ListStm
%name pBlock Block
%name pBlockExp BlockExp
%name pListBlockExp ListBlockExp
%name pExp Exp
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
%name pExp4 Exp4
%name pExp5 Exp5
%name pExp6 Exp6
%name pExp7 Exp7
%name pListExp ListExp
%name pAnonFunc AnonFunc
%name pMemberInit MemberInit
%name pListMemberInit ListMemberInit
%name pFormalArg FormalArg
%name pListFormalArg ListFormalArg
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '&&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '.' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  'Fn' { PT _ (TS _ 21) }
  'bool' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'false' { PT _ (TS _ 24) }
  'fn' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'int' { PT _ (TS _ 27) }
  'let' { PT _ (TS _ 28) }
  'print' { PT _ (TS _ 29) }
  'string' { PT _ (TS _ 30) }
  'struct' { PT _ (TS _ 31) }
  'true' { PT _ (TS _ 32) }
  'while' { PT _ (TS _ 33) }
  '{' { PT _ (TS _ 34) }
  '|' { PT _ (TS _ 35) }
  '||' { PT _ (TS _ 36) }
  '}' { PT _ (TS _ 37) }

  L_integ {PT _ (TI $$)}
  L_quoted {PT _ (TL $$)}
  L_ident {PT _ (TV $$)}

%%

Integer :: {
  Integer 
}
: L_integ {
  read $1 
}

String :: {
  String 
}
: L_quoted {
  $1 
}

Ident :: {
  Ident 
}
: L_ident {
  Ident $1 
}

Program :: {
  Program 
}
: ListStm {
  AbsStretch.ProgramEntry (reverse $1)
}

Boolean :: {
  Boolean 
}
: 'true' {
  AbsStretch.Boolean_true 
}
| 'false' {
  AbsStretch.Boolean_false 
}

Literal :: {
  Literal 
}
: '(' ')' {
  AbsStretch.LiteralUnit 
}
| Boolean {
  AbsStretch.LiteralBoolean $1 
}
| Integer {
  AbsStretch.LiteralInteger $1 
}
| String {
  AbsStretch.LiteralString $1 
}

Type :: {
  Type 
}
: Ident {
  AbsStretch.TyIdent $1 
}
| '(' ')' {
  AbsStretch.TyUnit 
}
| 'bool' {
  AbsStretch.TyBool 
}
| 'int' {
  AbsStretch.TyInt 
}
| 'string' {
  AbsStretch.TyString 
}
| 'Fn' '(' ListType ')' '->' Type {
  AbsStretch.TyFun $3 $6 
}

ListType :: {
  [Type]
}
: {
  [] 
}
| Type {
  (:[]) $1 
}
| Type ',' ListType {
  (:) $1 $3 
}

Stm :: {
  Stm 
}
: 'fn' Ident '(' ListFormalArg ')' Block {
  AbsStretch.SFunc $2 $4 $6 
}
| 'fn' Ident '(' ListFormalArg ')' '->' Type Block {
  AbsStretch.SFuncRet $2 $4 $7 $8 
}
| 'struct' Ident '{' ListFormalArg '}' {
  AbsStretch.SStruct $2 $4 
}
| 'let' Ident '=' Exp ';' {
  AbsStretch.SLet $2 $4 
}
| 'let' Ident ':' Type '=' Exp ';' {
  AbsStretch.SLetType $2 $4 $6 
}
| BlockExp {
  AbsStretch.SBlockExp $1 
}
| Exp ';' {
  AbsStretch.SExp $1 
}
| Stm ';' {
  $1 
}

ListStm :: {
  [Stm]
}
: {
  [] 
}
| ListStm Stm {
  flip (:) $1 $2 
}

Block :: {
  Block 
}
: '{' ListStm '}' {
  AbsStretch.Block1 (reverse $2)
}
| '{' ListStm Exp '}' {
  AbsStretch.Block2 (reverse $2)$3 
}

BlockExp :: {
  BlockExp 
}
: Block {
  AbsStretch.EBlock $1 
}
| 'if' Exp Block {
  AbsStretch.EIf $2 $3 
}
| 'if' Exp Block 'else' Block {
  AbsStretch.EIfElse $2 $3 $5 
}
| 'while' Exp Block {
  AbsStretch.EWhile $2 $3 
}

ListBlockExp :: {
  [BlockExp]
}
: {
  [] 
}
| ListBlockExp BlockExp {
  flip (:) $1 $2 
}

Exp :: {
  Exp 
}
: Ident '=' Exp {
  AbsStretch.EAssign $1 $3 
}
| Exp1 {
  $1 
}

Exp1 :: {
  Exp 
}
: Exp1 '||' Exp2 {
  AbsStretch.EOr $1 $3 
}
| Exp2 {
  $1 
}

Exp2 :: {
  Exp 
}
: Exp2 '&&' Exp3 {
  AbsStretch.EAnd $1 $3 
}
| Exp3 {
  $1 
}

Exp3 :: {
  Exp 
}
: Exp3 '==' Exp4 {
  AbsStretch.EEq $1 $3 
}
| Exp3 '!=' Exp4 {
  AbsStretch.ENEq $1 $3 
}
| Exp3 '<' Exp4 {
  AbsStretch.ELess $1 $3 
}
| Exp3 '<=' Exp4 {
  AbsStretch.ELEq $1 $3 
}
| Exp3 '>' Exp4 {
  AbsStretch.EGreat $1 $3 
}
| Exp3 '>=' Exp4 {
  AbsStretch.EGEq $1 $3 
}
| Exp4 {
  $1 
}

Exp4 :: {
  Exp 
}
: Exp4 '+' Exp5 {
  AbsStretch.EPlus $1 $3 
}
| Exp4 '-' Exp5 {
  AbsStretch.EMinus $1 $3 
}
| Exp5 {
  $1 
}

Exp5 :: {
  Exp 
}
: Exp5 '*' Exp6 {
  AbsStretch.EMul $1 $3 
}
| Exp5 '/' Exp6 {
  AbsStretch.EDiv $1 $3 
}
| Exp6 {
  $1 
}

Exp6 :: {
  Exp 
}
: '!' Exp7 {
  AbsStretch.ENot $2 
}
| '-' Exp7 {
  AbsStretch.ENeg $2 
}
| Exp7 {
  $1 
}

Exp7 :: {
  Exp 
}
: Literal {
  AbsStretch.ELit $1 
}
| Ident {
  AbsStretch.EIdent $1 
}
| Ident '{' ListMemberInit '}' {
  AbsStretch.EStruct $1 $3 
}
| Exp7 '(' ListExp ')' {
  AbsStretch.ECall $1 $3 
}
| 'print' '(' Exp ')' {
  AbsStretch.EPrint $3 
}
| Exp7 '.' Ident {
  AbsStretch.EField $1 $3 
}
| BlockExp {
  AbsStretch.EBlockExp $1 
}
| AnonFunc {
  AbsStretch.EAnonFun $1 
}
| '(' Exp ')' {
  $2 
}

ListExp :: {
  [Exp]
}
: {
  [] 
}
| Exp {
  (:[]) $1 
}
| Exp ',' ListExp {
  (:) $1 $3 
}

AnonFunc :: {
  AnonFunc 
}
: '||' Block {
  AbsStretch.AnonEmpty $2 
}
| '|' ListFormalArg '|' Block {
  AbsStretch.AnonArgs $2 $4 
}

MemberInit :: {
  MemberInit 
}
: Ident ':' Exp {
  AbsStretch.MemberExp $1 $3 
}

ListMemberInit :: {
  [MemberInit]
}
: {
  [] 
}
| MemberInit {
  (:[]) $1 
}
| MemberInit ',' ListMemberInit {
  (:) $1 $3 
}

FormalArg :: {
  FormalArg 
}
: Ident ':' Type {
  AbsStretch.TypedIdent $1 $3 
}

ListFormalArg :: {
  [FormalArg]
}
: {
  [] 
}
| FormalArg {
  (:[]) $1 
}
| FormalArg ',' ListFormalArg {
  (:) $1 $3 
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens


}

